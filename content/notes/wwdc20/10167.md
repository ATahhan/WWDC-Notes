---
contributors: dasauto, skhillon
---

> To get the most out of it, you should be familiar with Swift and the C programming language.
> 
> The following notes will assume you understand pointers in C.
> 
> This topic is not the kind of details that application programmers typically need to worry about.

Managing pointers safely means knowing all the different ways they can be unsafe.

## Levels of safety

![][levels_of_safety]

| Level of safety | Swift API                      | Description                                                                                                              |
|-----------------|--------------------------------|--------------------------------------------------------------------------------------------------------------------------|
| Safe            | `collections`, `slices`, `iterators` | Safe code. It's recommended write code at the highest safety level possible. **Not using pointers at all is a great strategy for code safety.**                                             |
| Unsafe          | `UnsafePointer<T>`               | UnsafePointer lets use pointers without worrying about type safety. |
| Raw             | `UnsafeRawPointer`               | UnsafeRawPointer lets you work with raw memory as a sequence of bytes.                                                   |
| Mutable type    | Memory-binding APIs            | Swift provides a few APIs for binding memory to types.                                                                   |

### Safe Swift code

![][safe_swift_code]

* Safe code isn't necessarily correct code but it does behave predictably.
* The compiler will catch the error if a programming error can lead to unpredictable behavior.
* Runtime checks guarantee the error will make the program crashes immediately.
* Safe code is really about error enforcement.

### Unsafe Swift code

![][unsafe_swift_code]

* Testing provides helpful diagnostics, but depends on the level of safety.
* Unsafe standard library APIs have assertions and debug builds that catch certain kinds of invalid input.
* Adding own preconditions to verify unsafe assumptions is a good practice.
* Sanitizer Diagnostics are great to pinpoint bugs, but don't catch all undefined behavior.
* When errors are not uncovered during testing they can lead to unexpected runtime behavior, the worst thing is corrupting or losing data.

## Pointer Safety
### Pointer's unsafe reason 1

![][pointer_lifetime_1]
![][pointer_lifetime_2]

* It needs a stable memory location before creating a pointer.
* The stable memory location has a limited lifetime - the memory location might not in the current stack frame or the memory gets deallocated directly.
* Any behavior is undefined, if a pointer accesses an invalid memory address.

### Pointer's unsafe reason 2

![][pointer_object_boundary]

* A memory location can fit in multiple objects. For example, a 64-bit memory can fit in two `Int32` type objects.
* Pointers are allowed to move to different memory addresses by adding offsets to the pointer.
* Adding or subtracting too large to the pointer, might access to the different object. 
* Accessing a pointer that has exceeded its object's boundary is undefined.

### Pointer's unsafe reason 3

![][pointer_type_1]
![][pointer_type_2]

* Pointers have their own types, they're different from the types of values in memory.
* If the pointer we have is a type of `Int16`, then we overwrite the memory location to store a `Int32` object, the pointer type will be inconsistent.
* Accessing the old pointer of type `Int16` is undefined behavior.

#### Pointer type bugs
* Different versions of complier can cause different program behavior.
* May cause unexpected behavior.
* May remain hidden for a long time.
* May be exposed at surprising times:
	* By safe-looking source change.
	* By a compiler update.

## Swift type-safe pointers
### Pointer type rules for Swift and C

* C has rules for "strict aliasing" and "type punning".
* Swift pointers can be used safely without knowing C rules.
* Swift pointers safely interoperate with C because they are, at minimum, as safe as C pointers. 
* In exchange, you need to take responsibility for object lifetime and object boundaries. 
* You can learn more in the [Unsafe Swift](https://github.com/skhillon/WWDC-Notes/blob/safe-pointers/content/notes/10648) talk.

### `UnsafePointer<T>` is a *typed pointer*

![][type_safe_pointer]

* In C, it's common to cast pointers to different types with both pointers continuing to refer to the same memory.
* `UnsafePointer<T>` only reads values of that type from memory.
* `UnsafeMutablePointer<T>` only reads or writes values of that type.
* It's undefined behavior in Swift to access a pointer whose type parameter does not match its memory location's bound type.
* Pointer types are enforced at compile time by Swift's type system.

### Pointers to variables

![][pointer_to_variables]

* Declare a variable of type int, then ask for a pointer, will get back a pointer to int.

### Pointers to arrays

![][pointer_to_arrays]

* Array storage is bound to the array element type.
* Asking for a pointer into array storage gives back a pointer to the arrays element type.

### Type-safe direct memory allocation

```swift
func directAllocation<T>(t: T, count: Int) {
    let tPtr = UnsafeMutablePointer<T>.allocate(capacity: count)
    tPtr.initialize(repeating: t, count: count)
    tPtr.assign(repeating: t, count: count)
    tPtr.deinitialize(count: count)
    tPtr.deallocate()
}
```

![][type_safe_memory_allocation]

* Allocate memory directly by calling the static allocate method on `UnsafeMutablePointer`.
* Allocation binds memory to its type parameter and returns a typed pointer to the new memory.
* Use the pointer to initialize memory only to the correct type. 
* In the initialized state, memory can be reassigned.
* De-initialize memory using the same typed pointer. Then can be safe to de-allocate.

### Composite types in memory

![][composite_type]

* Generally won't have two active pointers to the same memory location that disagree on the type.
* It's able to either get a pointer to the outer struct or a pointer to its property, they are both valid at the same time. 

## Swift *raw* pointers

* `UnsafeRawPointer` lets you refer to a sequence of bytes without specifying the type. 
* You take control over memory layout.

### Loading bytes with `UnsafeRawPointer`

![][loading_bytes_with_raw]

* It's able to interpret bytes as typed values. 
* It's always possible to cast from a typed pointer down to a raw pointer. 
* Operations on raw pointer only see the sequence of bytes in memory. 
* It's able to ask that raw pointer to load any type. 

#### Example

![][loading_bytes_with_raw_example]

* Call `.load(as: UInt32.self)` on a `Int64` pointer.
* It loads the lower 4 bytes from the memory location.
* Then it interprets the 4 bytes as a `UInt32` value.
* From a two's compliment number to an unsigned number.

### Storing bytes with `UnsafeMutableRawPointer`

![][storing_bytes_with_raw]

* Storing bytes is asymmetric with loading because it modifies the in-memory value. 
* Storing raw bytes does not de-initialize the previous value in memory. 
* To make sure the memory doesn't contain any object references.

#### Example

![][storing_bytes_with_raw_example]

* Call `.storeBytes(of: u, as: UInt32.self)` extracts 4 bytes from a `UInt32` value `u`, writing them into the upper 4 bytes of an in-memory `Int64` value.
* The typed pointer that already points to the in-memory value can still be used to access it, but with different value.
* Cannot cast a raw pointer back into a typed pointer because it conflicts with the memories bound type.
* In this case, `Int64` pointer overlaps with `UInt32` pointer.

[levels_of_safety]: ../../../images/notes/wwdc20/10167/levels_of_safety.png
[safe_swift_code]: ../../../images/notes/wwdc20/10167/safe_swift_code.png
[unsafe_swift_code]: ../../../images/notes/wwdc20/10167/unsafe_swift_code.png
[pointer_lifetime_1]: ../../../images/notes/wwdc20/10167/pointer_lifetime_1.png
[pointer_lifetime_2]: ../../../images/notes/wwdc20/10167/pointer_lifetime_2.png
[pointer_object_boundary]: ../../../images/notes/wwdc20/10167/pointer_object_boundary.png
[pointer_type_1]: ../../../images/notes/wwdc20/10167/pointer_type_1.png
[pointer_type_2]: ../../../images/notes/wwdc20/10167/pointer_type_2.png
[type_safe_pointer]: ../../../images/notes/wwdc20/10167/type_safe_pointer.png
[pointer_to_variables]: ../../../images/notes/wwdc20/10167/pointer_to_variables.png
[pointer_to_arrays]: ../../../images/notes/wwdc20/10167/pointer_to_arrays.png
[type_safe_memory_allocation]: ../../../images/notes/wwdc20/10167/type_safe_memory_allocation.png
[composite_type]: ../../../images/notes/wwdc20/10167/composite_type.png
[loading_bytes_with_raw]: ../../../images/notes/wwdc20/10167/loading_bytes_with_raw.png
[loading_bytes_with_raw_example]: ../../../images/notes/wwdc20/10167/loading_bytes_with_raw_example.png
[storing_bytes_with_raw]: ../../../images/notes/wwdc20/10167/storing_bytes_with_raw.png
[storing_bytes_with_raw_example]: ../../../images/notes/wwdc20/10167/storing_bytes_with_raw_example.png